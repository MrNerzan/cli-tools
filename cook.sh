#!/bin/bash

# Output executable name
OUTPUT="cli-tools"
BUILD_DIR="build"

# Temporary files (you can add other file extensions if needed)
# shellcheck disable=SC2034
TEMP_FILES="*.o"

# Functions

# Clean function (does not remove the output executable)
clean() {
    echo "Cleaning up..."
    rm -rf $BUILD_DIR  # Remove the entire build directory
    echo "Environment cleaned."
}
clean() {
    echo "Cleaning up CMake-generated files..."

    # Remove CMake cache and autogenerated files
    if [ -d "$BUILD_DIR" ]; then
        rm -f "$BUILD_DIR/CMakeCache.txt"         # Remove the CMake cache
        rm -rf "$BUILD_DIR/CMakeFiles"            # Remove the CMake files directory
        rm -f "$BUILD_DIR/*.o"                     # Remove object files
        rm -f "$BUILD_DIR/*.d"                     # Remove dependency files
        rm -f "$BUILD_DIR/*.cmake"                 # Remove CMake configuration files
        echo "CMake-generated files removed from $BUILD_DIR."
    else
        echo "$BUILD_DIR directory does not exist."
    fi

    echo "Environment cleaned."
}

# Generate documentation
generate_docs() {
    echo "Generating documentation..."

    # Create the necessary directories if they don't exist
    mkdir -p docs/functions docs/variables docs/headers

    # Create a main docs.md file for the table of contents
    docs_md="docs/docs.md"
    echo "# Documentation Table of Contents" > "$docs_md"
    echo "" >> "$docs_md"

    # List of C types to ignore
    ignore_types="char|int|uint8_t|size_t|bool|float|double|long|short|void"

    # Loop through all .h files in the src/headers directory
    for header_file in src/headers/*.h; do
        if [[ -f "$header_file" ]]; then
            # Create a TOC file for the current header file with the suffix _H
            toc_filename="docs/headers/$(basename "$header_file" .h)_H.md"
            echo "# Table of Contents for $(basename "$header_file")" > "$toc_filename"
            echo "" >> "$toc_filename"
            echo "Original file: [$(basename "$header_file")](./$header_file)" >> "$toc_filename"
            echo "" >> "$toc_filename"

            # Add the header file name to the main docs.md
            echo "## Header File: [$(basename "$header_file")](./headers/$(basename "$header_file" .h)_H.md)" >> "$docs_md"
            echo "### Functions" >> "$docs_md"

            # Process global variables and types
            gawk -v file="$header_file" -v toc_filename="$toc_filename" -v docs_md="$docs_md" -v ignore_types="$ignore_types" '
            BEGIN {
                print "## Global Variables" >> toc_filename
            }
            /^extern / {
                line = $0
                sub(/^extern /, "", line)
                sub(/;$/, "", line)

                if (match(line, /([A-Za-z_][A-Za-z0-9_]*)$/, arr)) {
                    var_name = arr[1]
                } else {
                    next
                }

                sub(/^[^ ]+ +/, "", line)
                while (match(line, /^([*]+|&)+ */)) {
                    sub(/^([*]+|&)+ */, "", line)
                }

                if (var_name ~ /^('"${ignore_types}"')/) {
                    sub(/^('"${ignore_types}"') +/, "", var_name)
                }

                getline description
                while (description ~ /^\/\//) {
                    print description
                    getline description
                }

                var_filename = "docs/variables/" var_name "_variable.md"
                print "# Global Variable" > var_filename
                print "" >> var_filename
                print "## " var_name "" >> var_filename
                print description >> var_filename
                print "" >> var_filename
                print "extern " $0 >> var_filename
                print "" >> var_filename
                print "---" >> var_filename

                print "Global Variable: [" var_name "](./variables/" var_name "_variable.md)" >> toc_filename
                print "Global Variable: [" var_name "](./variables/" var_name "_variable.md)" >> docs_md
            }' "$header_file"

            # Process functions
            gawk -v file="$header_file" -v toc_filename="$toc_filename" -v docs_md="$docs_md" '
            BEGIN {
                print "## Functions" >> toc_filename
            }
            /^void |^bool / {
                func_signature = $0
                func_name = $2
                func_name = gensub(/\(.*$/, "", "g", func_name)

                getline description
                while (description ~ /^\/\//) {
                    print description
                    getline description
                }

                func_filename = "docs/functions/" func_name "_function.md"
                print "# Function: " func_signature "" > func_filename
                print "" >> func_filename
                print "## Brief Description" >> func_filename
                print description >> func_filename
                print "" >> func_filename
                print "## Parameters" >> func_filename

                gsub(/^.*\(/, "", func_signature)
                gsub(/\).*/, "", func_signature)
                n = split(func_signature, params, ",")
                for (i = 1; i <= n; i++) {
                    gsub(/^[ ]+|[ ]+$/, "", params[i])
                    print "- **" params[i] "**" >> func_filename
                }

                print "" >> func_filename
                print "## Return Value" >> func_filename
                print "- **Returns**: true if the filename was loaded successfully, false otherwise." >> func_filename
                print "" >> func_filename
                print func_signature >> func_filename
                print "" >> func_filename

                print "[" func_name "](./functions/" func_name "_function.md)" >> toc_filename
                print "  - [" func_name "](./functions/" func_name "_function.md)" >> docs_md
            }' "$header_file"

            echo "" >> "$toc_filename"
            echo "---" >> "$toc_filename"
            echo "Documented by the cook." >> "$toc_filename"
        fi
    done

    echo "Documentation generation complete."
}

# Build the program inside the build directory
build() {
    local BUILD_TYPE=$1
    local CMAKE_BUILD_TYPE=""

    if [ "$BUILD_TYPE" == "debug" ]; then
        echo "Building in debug mode..."
        CMAKE_BUILD_TYPE="Debug"
    elif [ "$BUILD_TYPE" == "release" ]; then
        echo "Building in release mode..."
        CMAKE_BUILD_TYPE="Release"
    else
        echo "Usage: $0 {build debug|build release|clean|docs|test|install_dependencies}"
        exit 1
    fi

    # Ensure the build directory exists
    mkdir -p $BUILD_DIR
    cd $BUILD_DIR || exit 1  # Navigate into the build directory

    # Configure the project using CMake
    cmake -DCMAKE_BUILD_TYPE=$CMAKE_BUILD_TYPE .. || { echo "CMake configuration failed."; exit 1; }

    # Build the project
    cmake --build . || { echo "Build failed."; exit 1; }

    # Copy help file if the build was successful
    echo "Build successful: ./$OUTPUT"
    cp ../HELP.md ./HELP.md
}

run_tests() {
    echo "Running tests..."
    if [ -f "./tests/run_tests.sh" ]; then
        ./tests/run_tests.sh || { echo "Tests failed."; exit 1; }
    else
        echo "Test script not found, ensure it exists at ./tests/run_tests.sh"
    fi
}

install_dependencies() {
    echo "Installing dependencies..."

    # Example using apt-get (for Ubuntu/Debian)
    if command -v apt-get > /dev/null; then
        sudo apt-get update
        sudo apt-get install -y gcc make cmake libtool
        echo "Dependencies installed via apt-get."

    # Example using brew (for macOS)
    elif command -v brew > /dev/null; then
        brew update
        brew install gcc cmake libtool
        echo "Dependencies installed via brew."

    # Example using yum (for Fedora/RedHat/CentOS)
    elif command -v yum > /dev/null; then
        sudo yum install -y gcc make cmake libtool
        echo "Dependencies installed via yum."

    else
        echo "Unsupported package manager. Please install dependencies manually."
        exit 1
    fi
}

# Main logic
case $1 in
    build) build "$2" ;;
    clean) clean ;;
    docs) generate_docs ;;
    test) run_tests ;;
    install) install_dependencies ;;
    *) echo "Usage: $0 {build debug|build release|clean|docs|test|install_dependencies}" ;;
esac
